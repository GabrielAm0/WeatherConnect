{"ast":null,"code":"function t(t, e, i) {\n  return Math.max(t, Math.min(e, i));\n}\nclass Animate {\n  advance(e) {\n    if (!this.isRunning) return;\n    let i = !1;\n    if (this.lerp) this.value = (s = this.value, o = this.to, n = 60 * this.lerp, r = e, function (t, e, i) {\n      return (1 - i) * t + i * e;\n    }(s, o, 1 - Math.exp(-n * r))), Math.round(this.value) === this.to && (this.value = this.to, i = !0);else {\n      this.currentTime += e;\n      const s = t(0, this.currentTime / this.duration, 1);\n      i = s >= 1;\n      const o = i ? 1 : this.easing(s);\n      this.value = this.from + (this.to - this.from) * o;\n    }\n    var s, o, n, r;\n    this.onUpdate?.(this.value, i), i && this.stop();\n  }\n  stop() {\n    this.isRunning = !1;\n  }\n  fromTo(t, e, {\n    lerp: i = .1,\n    duration: s = 1,\n    easing: o = t => t,\n    onStart: n,\n    onUpdate: r\n  }) {\n    this.from = this.value = t, this.to = e, this.lerp = i, this.duration = s, this.easing = o, this.currentTime = 0, this.isRunning = !0, n?.(), this.onUpdate = r;\n  }\n}\nclass Dimensions {\n  constructor({\n    wrapper: t,\n    content: e,\n    autoResize: i = !0\n  } = {}) {\n    if (this.wrapper = t, this.content = e, i) {\n      const t = function (t, e) {\n        let i;\n        return function () {\n          let s = arguments,\n            o = this;\n          clearTimeout(i), i = setTimeout(function () {\n            t.apply(o, s);\n          }, e);\n        };\n      }(this.resize, 250);\n      this.wrapper !== window && (this.wrapperResizeObserver = new ResizeObserver(t), this.wrapperResizeObserver.observe(this.wrapper)), this.contentResizeObserver = new ResizeObserver(t), this.contentResizeObserver.observe(this.content);\n    }\n    this.resize();\n  }\n  destroy() {\n    this.wrapperResizeObserver?.disconnect(), this.contentResizeObserver?.disconnect();\n  }\n  resize = () => {\n    this.onWrapperResize(), this.onContentResize();\n  };\n  onWrapperResize = () => {\n    this.wrapper === window ? (this.width = window.innerWidth, this.height = window.innerHeight) : (this.width = this.wrapper.clientWidth, this.height = this.wrapper.clientHeight);\n  };\n  onContentResize = () => {\n    this.scrollHeight = this.content.scrollHeight, this.scrollWidth = this.content.scrollWidth;\n  };\n  get limit() {\n    return {\n      x: this.scrollWidth - this.width,\n      y: this.scrollHeight - this.height\n    };\n  }\n}\nclass Emitter {\n  constructor() {\n    this.events = {};\n  }\n  emit(t, ...e) {\n    let i = this.events[t] || [];\n    for (let t = 0, s = i.length; t < s; t++) i[t](...e);\n  }\n  on(t, e) {\n    return this.events[t]?.push(e) || (this.events[t] = [e]), () => {\n      this.events[t] = this.events[t]?.filter(t => e !== t);\n    };\n  }\n  off(t, e) {\n    this.events[t] = this.events[t]?.filter(t => e !== t);\n  }\n  destroy() {\n    this.events = {};\n  }\n}\nclass VirtualScroll {\n  constructor(t, {\n    wheelMultiplier: e = 1,\n    touchMultiplier: i = 2,\n    normalizeWheel: s = !1\n  }) {\n    this.element = t, this.wheelMultiplier = e, this.touchMultiplier = i, this.normalizeWheel = s, this.touchStart = {\n      x: null,\n      y: null\n    }, this.emitter = new Emitter(), this.element.addEventListener(\"wheel\", this.onWheel, {\n      passive: !1\n    }), this.element.addEventListener(\"touchstart\", this.onTouchStart, {\n      passive: !1\n    }), this.element.addEventListener(\"touchmove\", this.onTouchMove, {\n      passive: !1\n    }), this.element.addEventListener(\"touchend\", this.onTouchEnd, {\n      passive: !1\n    });\n  }\n  on(t, e) {\n    return this.emitter.on(t, e);\n  }\n  destroy() {\n    this.emitter.destroy(), this.element.removeEventListener(\"wheel\", this.onWheel, {\n      passive: !1\n    }), this.element.removeEventListener(\"touchstart\", this.onTouchStart, {\n      passive: !1\n    }), this.element.removeEventListener(\"touchmove\", this.onTouchMove, {\n      passive: !1\n    }), this.element.removeEventListener(\"touchend\", this.onTouchEnd, {\n      passive: !1\n    });\n  }\n  onTouchStart = t => {\n    const {\n      clientX: e,\n      clientY: i\n    } = t.targetTouches ? t.targetTouches[0] : t;\n    this.touchStart.x = e, this.touchStart.y = i, this.lastDelta = {\n      x: 0,\n      y: 0\n    }, this.emitter.emit(\"scroll\", {\n      deltaX: 0,\n      deltaY: 0,\n      event: t\n    });\n  };\n  onTouchMove = t => {\n    const {\n        clientX: e,\n        clientY: i\n      } = t.targetTouches ? t.targetTouches[0] : t,\n      s = -(e - this.touchStart.x) * this.touchMultiplier,\n      o = -(i - this.touchStart.y) * this.touchMultiplier;\n    this.touchStart.x = e, this.touchStart.y = i, this.lastDelta = {\n      x: s,\n      y: o\n    }, this.emitter.emit(\"scroll\", {\n      deltaX: s,\n      deltaY: o,\n      event: t\n    });\n  };\n  onTouchEnd = t => {\n    this.emitter.emit(\"scroll\", {\n      deltaX: this.lastDelta.x,\n      deltaY: this.lastDelta.y,\n      event: t\n    });\n  };\n  onWheel = e => {\n    let {\n      deltaX: i,\n      deltaY: s\n    } = e;\n    this.normalizeWheel && (i = t(-100, i, 100), s = t(-100, s, 100)), i *= this.wheelMultiplier, s *= this.wheelMultiplier, this.emitter.emit(\"scroll\", {\n      deltaX: i,\n      deltaY: s,\n      event: e\n    });\n  };\n}\nclass Lenis {\n  constructor({\n    wrapper: t = window,\n    content: e = document.documentElement,\n    wheelEventsTarget: i = t,\n    eventsTarget: s = i,\n    smoothWheel: o = !0,\n    syncTouch: n = !1,\n    syncTouchLerp: r = .075,\n    touchInertiaMultiplier: l = 35,\n    duration: h,\n    easing: a = t => Math.min(1, 1.001 - Math.pow(2, -10 * t)),\n    lerp: c = !h && .1,\n    infinite: p = !1,\n    orientation: u = \"vertical\",\n    gestureOrientation: d = \"vertical\",\n    touchMultiplier: m = 1,\n    wheelMultiplier: g = 1,\n    normalizeWheel: v = !1,\n    autoResize: S = !0\n  } = {}) {\n    window.lenisVersion = \"1.0.34\", t !== document.documentElement && t !== document.body || (t = window), this.options = {\n      wrapper: t,\n      content: e,\n      wheelEventsTarget: i,\n      eventsTarget: s,\n      smoothWheel: o,\n      syncTouch: n,\n      syncTouchLerp: r,\n      touchInertiaMultiplier: l,\n      duration: h,\n      easing: a,\n      lerp: c,\n      infinite: p,\n      gestureOrientation: d,\n      orientation: u,\n      touchMultiplier: m,\n      wheelMultiplier: g,\n      normalizeWheel: v,\n      autoResize: S\n    }, this.animate = new Animate(), this.emitter = new Emitter(), this.dimensions = new Dimensions({\n      wrapper: t,\n      content: e,\n      autoResize: S\n    }), this.toggleClass(\"lenis\", !0), this.velocity = 0, this.isLocked = !1, this.isStopped = !1, this.isSmooth = n || o, this.isScrolling = !1, this.targetScroll = this.animatedScroll = this.actualScroll, this.options.wrapper.addEventListener(\"scroll\", this.onNativeScroll, {\n      passive: !1\n    }), this.virtualScroll = new VirtualScroll(s, {\n      touchMultiplier: m,\n      wheelMultiplier: g,\n      normalizeWheel: v\n    }), this.virtualScroll.on(\"scroll\", this.onVirtualScroll);\n  }\n  destroy() {\n    this.emitter.destroy(), this.options.wrapper.removeEventListener(\"scroll\", this.onNativeScroll, {\n      passive: !1\n    }), this.virtualScroll.destroy(), this.dimensions.destroy(), this.toggleClass(\"lenis\", !1), this.toggleClass(\"lenis-smooth\", !1), this.toggleClass(\"lenis-scrolling\", !1), this.toggleClass(\"lenis-stopped\", !1), this.toggleClass(\"lenis-locked\", !1);\n  }\n  on(t, e) {\n    return this.emitter.on(t, e);\n  }\n  off(t, e) {\n    return this.emitter.off(t, e);\n  }\n  setScroll(t) {\n    this.isHorizontal ? this.rootElement.scrollLeft = t : this.rootElement.scrollTop = t;\n  }\n  onVirtualScroll = ({\n    deltaX: t,\n    deltaY: e,\n    event: i\n  }) => {\n    if (i.ctrlKey) return;\n    const s = i.type.includes(\"touch\"),\n      o = i.type.includes(\"wheel\");\n    if (this.options.syncTouch && s && \"touchstart\" === i.type) return void this.reset();\n    const n = 0 === t && 0 === e,\n      r = \"vertical\" === this.options.gestureOrientation && 0 === e || \"horizontal\" === this.options.gestureOrientation && 0 === t;\n    if (n || r) return;\n    let l = i.composedPath();\n    if (l = l.slice(0, l.indexOf(this.rootElement)), l.find(t => t.hasAttribute?.(\"data-lenis-prevent\") || s && t.hasAttribute?.(\"data-lenis-prevent-touch\") || o && t.hasAttribute?.(\"data-lenis-prevent-wheel\") || t.classList?.contains(\"lenis\"))) return;\n    if (this.isStopped || this.isLocked) return void i.preventDefault();\n    if (this.isSmooth = this.options.syncTouch && s || this.options.smoothWheel && o, !this.isSmooth) return this.isScrolling = !1, void this.animate.stop();\n    i.preventDefault();\n    let h = e;\n    \"both\" === this.options.gestureOrientation ? h = Math.abs(e) > Math.abs(t) ? e : t : \"horizontal\" === this.options.gestureOrientation && (h = t);\n    const a = s && this.options.syncTouch,\n      c = s && \"touchend\" === i.type && Math.abs(h) > 5;\n    c && (h = this.velocity * this.options.touchInertiaMultiplier), this.scrollTo(this.targetScroll + h, {\n      programmatic: !1,\n      ...(a ? {\n        lerp: c ? this.options.syncTouchLerp : 1\n      } : {\n        lerp: this.options.lerp,\n        duration: this.options.duration,\n        easing: this.options.easing\n      })\n    });\n  };\n  resize() {\n    this.dimensions.resize();\n  }\n  emit() {\n    this.emitter.emit(\"scroll\", this);\n  }\n  onNativeScroll = () => {\n    if (!this.__preventNextScrollEvent && !this.isScrolling) {\n      const t = this.animatedScroll;\n      this.animatedScroll = this.targetScroll = this.actualScroll, this.velocity = 0, this.direction = Math.sign(this.animatedScroll - t), this.emit();\n    }\n  };\n  reset() {\n    this.isLocked = !1, this.isScrolling = !1, this.animatedScroll = this.targetScroll = this.actualScroll, this.velocity = 0, this.animate.stop();\n  }\n  start() {\n    this.isStopped = !1, this.reset();\n  }\n  stop() {\n    this.isStopped = !0, this.animate.stop(), this.reset();\n  }\n  raf(t) {\n    const e = t - (this.time || t);\n    this.time = t, this.animate.advance(.001 * e);\n  }\n  scrollTo(e, {\n    offset: i = 0,\n    immediate: s = !1,\n    lock: o = !1,\n    duration: n = this.options.duration,\n    easing: r = this.options.easing,\n    lerp: l = !n && this.options.lerp,\n    onComplete: h = null,\n    force: a = !1,\n    programmatic: c = !0\n  } = {}) {\n    if (!this.isStopped && !this.isLocked || a) {\n      if ([\"top\", \"left\", \"start\"].includes(e)) e = 0;else if ([\"bottom\", \"right\", \"end\"].includes(e)) e = this.limit;else {\n        let t;\n        if (\"string\" == typeof e ? t = document.querySelector(e) : e?.nodeType && (t = e), t) {\n          if (this.options.wrapper !== window) {\n            const t = this.options.wrapper.getBoundingClientRect();\n            i -= this.isHorizontal ? t.left : t.top;\n          }\n          const s = t.getBoundingClientRect();\n          e = (this.isHorizontal ? s.left : s.top) + this.animatedScroll;\n        }\n      }\n      if (\"number\" == typeof e) {\n        if (e += i, e = Math.round(e), this.options.infinite ? c && (this.targetScroll = this.animatedScroll = this.scroll) : e = t(0, e, this.limit), s) return this.animatedScroll = this.targetScroll = e, this.setScroll(this.scroll), this.reset(), void h?.(this);\n        if (!c) {\n          if (e === this.targetScroll) return;\n          this.targetScroll = e;\n        }\n        this.animate.fromTo(this.animatedScroll, e, {\n          duration: n,\n          easing: r,\n          lerp: l,\n          onStart: () => {\n            o && (this.isLocked = !0), this.isScrolling = !0;\n          },\n          onUpdate: (t, e) => {\n            this.isScrolling = !0, this.velocity = t - this.animatedScroll, this.direction = Math.sign(this.velocity), this.animatedScroll = t, this.setScroll(this.scroll), c && (this.targetScroll = t), e || this.emit(), e && (this.reset(), this.emit(), h?.(this), this.__preventNextScrollEvent = !0, requestAnimationFrame(() => {\n              delete this.__preventNextScrollEvent;\n            }));\n          }\n        });\n      }\n    }\n  }\n  get rootElement() {\n    return this.options.wrapper === window ? document.documentElement : this.options.wrapper;\n  }\n  get limit() {\n    return this.dimensions.limit[this.isHorizontal ? \"x\" : \"y\"];\n  }\n  get isHorizontal() {\n    return \"horizontal\" === this.options.orientation;\n  }\n  get actualScroll() {\n    return this.isHorizontal ? this.rootElement.scrollLeft : this.rootElement.scrollTop;\n  }\n  get scroll() {\n    return this.options.infinite ? (t = this.animatedScroll, e = this.limit, (t % e + e) % e) : this.animatedScroll;\n    var t, e;\n  }\n  get progress() {\n    return 0 === this.limit ? 1 : this.scroll / this.limit;\n  }\n  get isSmooth() {\n    return this.__isSmooth;\n  }\n  set isSmooth(t) {\n    this.__isSmooth !== t && (this.__isSmooth = t, this.toggleClass(\"lenis-smooth\", t));\n  }\n  get isScrolling() {\n    return this.__isScrolling;\n  }\n  set isScrolling(t) {\n    this.__isScrolling !== t && (this.__isScrolling = t, this.toggleClass(\"lenis-scrolling\", t));\n  }\n  get isStopped() {\n    return this.__isStopped;\n  }\n  set isStopped(t) {\n    this.__isStopped !== t && (this.__isStopped = t, this.toggleClass(\"lenis-stopped\", t));\n  }\n  get isLocked() {\n    return this.__isLocked;\n  }\n  set isLocked(t) {\n    this.__isLocked !== t && (this.__isLocked = t, this.toggleClass(\"lenis-locked\", t));\n  }\n  get className() {\n    let t = \"lenis\";\n    return this.isStopped && (t += \" lenis-stopped\"), this.isLocked && (t += \" lenis-locked\"), this.isScrolling && (t += \" lenis-scrolling\"), this.isSmooth && (t += \" lenis-smooth\"), t;\n  }\n  toggleClass(t, e) {\n    this.rootElement.classList.toggle(t, e), this.emitter.emit(\"className change\", this);\n  }\n}\nexport { Lenis as default };","map":{"version":3,"names":["t","e","i","Math","max","min","Animate","advance","isRunning","lerp","value","s","o","to","n","r","exp","round","currentTime","duration","easing","from","onUpdate","stop","fromTo","onStart","Dimensions","constructor","wrapper","content","autoResize","arguments","clearTimeout","setTimeout","apply","resize","window","wrapperResizeObserver","ResizeObserver","observe","contentResizeObserver","destroy","disconnect","onWrapperResize","onContentResize","width","innerWidth","height","innerHeight","clientWidth","clientHeight","scrollHeight","scrollWidth","limit","x","y","Emitter","events","emit","length","on","push","filter","off","VirtualScroll","wheelMultiplier","touchMultiplier","normalizeWheel","element","touchStart","emitter","addEventListener","onWheel","passive","onTouchStart","onTouchMove","onTouchEnd","removeEventListener","clientX","clientY","targetTouches","lastDelta","deltaX","deltaY","event","Lenis","document","documentElement","wheelEventsTarget","eventsTarget","smoothWheel","syncTouch","syncTouchLerp","touchInertiaMultiplier","l","h","a","pow","c","infinite","p","orientation","u","gestureOrientation","d","m","g","v","S","lenisVersion","body","options","animate","dimensions","toggleClass","velocity","isLocked","isStopped","isSmooth","isScrolling","targetScroll","animatedScroll","actualScroll","onNativeScroll","virtualScroll","onVirtualScroll","setScroll","isHorizontal","rootElement","scrollLeft","scrollTop","ctrlKey","type","includes","reset","composedPath","slice","indexOf","find","hasAttribute","classList","contains","preventDefault","abs","scrollTo","programmatic","__preventNextScrollEvent","direction","sign","start","raf","time","offset","immediate","lock","onComplete","force","querySelector","nodeType","getBoundingClientRect","left","top","scroll","requestAnimationFrame","progress","__isSmooth","__isScrolling","__isStopped","__isLocked","className","toggle","default"],"sources":["C:\\Users\\gabriel.custodio\\Documents\\GitHub\\WeatherConnect\\front\\weather-connect-app\\node_modules\\@studio-freight\\lenis\\src\\maths.js","C:\\Users\\gabriel.custodio\\Documents\\GitHub\\WeatherConnect\\front\\weather-connect-app\\node_modules\\@studio-freight\\lenis\\src\\animate.js","C:\\Users\\gabriel.custodio\\Documents\\GitHub\\WeatherConnect\\front\\weather-connect-app\\node_modules\\@studio-freight\\lenis\\src\\dimensions.js","C:\\Users\\gabriel.custodio\\Documents\\GitHub\\WeatherConnect\\front\\weather-connect-app\\node_modules\\@studio-freight\\lenis\\src\\debounce.js","C:\\Users\\gabriel.custodio\\Documents\\GitHub\\WeatherConnect\\front\\weather-connect-app\\node_modules\\@studio-freight\\lenis\\src\\emitter.js","C:\\Users\\gabriel.custodio\\Documents\\GitHub\\WeatherConnect\\front\\weather-connect-app\\node_modules\\@studio-freight\\lenis\\src\\virtual-scroll.js","C:\\Users\\gabriel.custodio\\Documents\\GitHub\\WeatherConnect\\front\\weather-connect-app\\node_modules\\@studio-freight\\lenis\\src\\index.js"],"sourcesContent":["// Clamp a value between a minimum and maximum value\nexport function clamp(min, input, max) {\n  return Math.max(min, Math.min(input, max))\n}\n\n// Truncate a floating-point number to a specified number of decimal places\nexport function truncate(value, decimals = 0) {\n  return parseFloat(value.toFixed(decimals))\n}\n\n// Linearly interpolate between two values using an amount (0 <= t <= 1)\nexport function lerp(x, y, t) {\n  return (1 - t) * x + t * y\n}\n\n// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\nexport function damp(x, y, lambda, dt) {\n  return lerp(x, y, 1 - Math.exp(-lambda * dt))\n}\n\n// Calculate the modulo of the dividend and divisor while keeping the result within the same sign as the divisor\n// https://anguscroll.com/just/just-modulo\nexport function modulo(n, d) {\n  return ((n % d) + d) % d\n}\n","import { clamp, damp } from './maths'\n\n// Animate class to handle value animations with lerping or easing\nexport class Animate {\n  // Advance the animation by the given delta time\n  advance(deltaTime) {\n    if (!this.isRunning) return\n\n    let completed = false\n\n    if (this.lerp) {\n      this.value = damp(this.value, this.to, this.lerp * 60, deltaTime)\n      if (Math.round(this.value) === this.to) {\n        this.value = this.to\n        completed = true\n      }\n    } else {\n      this.currentTime += deltaTime\n      const linearProgress = clamp(0, this.currentTime / this.duration, 1)\n\n      completed = linearProgress >= 1\n      const easedProgress = completed ? 1 : this.easing(linearProgress)\n      this.value = this.from + (this.to - this.from) * easedProgress\n    }\n\n    // Call the onUpdate callback with the current value and completed status\n    this.onUpdate?.(this.value, completed)\n\n    if (completed) {\n      this.stop()\n    }\n  }\n\n  // Stop the animation\n  stop() {\n    this.isRunning = false\n  }\n\n  // Set up the animation from a starting value to an ending value\n  // with optional parameters for lerping, duration, easing, and onUpdate callback\n  fromTo(\n    from,\n    to,\n    { lerp = 0.1, duration = 1, easing = (t) => t, onStart, onUpdate }\n  ) {\n    this.from = this.value = from\n    this.to = to\n    this.lerp = lerp\n    this.duration = duration\n    this.easing = easing\n    this.currentTime = 0\n    this.isRunning = true\n\n    onStart?.()\n    this.onUpdate = onUpdate\n  }\n}\n","import { debounce } from './debounce'\n\nexport class Dimensions {\n  constructor({ wrapper, content, autoResize = true } = {}) {\n    this.wrapper = wrapper\n    this.content = content\n\n    if (autoResize) {\n      const resize = debounce(this.resize, 250)\n\n      if (this.wrapper !== window) {\n        this.wrapperResizeObserver = new ResizeObserver(resize)\n        this.wrapperResizeObserver.observe(this.wrapper)\n      }\n\n      this.contentResizeObserver = new ResizeObserver(resize)\n      this.contentResizeObserver.observe(this.content)\n    }\n\n    this.resize()\n  }\n\n  destroy() {\n    this.wrapperResizeObserver?.disconnect()\n    this.contentResizeObserver?.disconnect()\n  }\n\n  resize = () => {\n    this.onWrapperResize()\n    this.onContentResize()\n  }\n\n  onWrapperResize = () => {\n    if (this.wrapper === window) {\n      this.width = window.innerWidth\n      this.height = window.innerHeight\n    } else {\n      this.width = this.wrapper.clientWidth\n      this.height = this.wrapper.clientHeight\n    }\n  }\n\n  onContentResize = () => {\n    this.scrollHeight = this.content.scrollHeight\n    this.scrollWidth = this.content.scrollWidth\n  }\n\n  get limit() {\n    return {\n      x: this.scrollWidth - this.width,\n      y: this.scrollHeight - this.height,\n    }\n  }\n}\n","export function debounce(callback, delay) {\n  let timer\n  return function () {\n    let args = arguments\n    let context = this\n    clearTimeout(timer)\n    timer = setTimeout(function () {\n      callback.apply(context, args)\n    }, delay)\n  }\n}\n","export class Emitter {\n  constructor() {\n    this.events = {}\n  }\n\n  emit(event, ...args) {\n    let callbacks = this.events[event] || []\n    for (let i = 0, length = callbacks.length; i < length; i++) {\n      callbacks[i](...args)\n    }\n  }\n\n  on(event, cb) {\n    // Add the callback to the event's callback list, or create a new list with the callback\n    this.events[event]?.push(cb) || (this.events[event] = [cb])\n\n    // Return an unsubscribe function\n    return () => {\n      this.events[event] = this.events[event]?.filter((i) => cb !== i)\n    }\n  }\n\n  off(event, callback) {\n    this.events[event] = this.events[event]?.filter((i) => callback !== i)\n  }\n\n  destroy() {\n    this.events = {}\n  }\n}\n","import { Emitter } from './emitter'\nimport { clamp } from './maths'\n\nexport class VirtualScroll {\n  constructor(\n    element,\n    { wheelMultiplier = 1, touchMultiplier = 2, normalizeWheel = false }\n  ) {\n    this.element = element\n    this.wheelMultiplier = wheelMultiplier\n    this.touchMultiplier = touchMultiplier\n    this.normalizeWheel = normalizeWheel\n\n    this.touchStart = {\n      x: null,\n      y: null,\n    }\n\n    this.emitter = new Emitter()\n\n    this.element.addEventListener('wheel', this.onWheel, { passive: false })\n    this.element.addEventListener('touchstart', this.onTouchStart, {\n      passive: false,\n    })\n    this.element.addEventListener('touchmove', this.onTouchMove, {\n      passive: false,\n    })\n    this.element.addEventListener('touchend', this.onTouchEnd, {\n      passive: false,\n    })\n  }\n\n  // Add an event listener for the given event and callback\n  on(event, callback) {\n    return this.emitter.on(event, callback)\n  }\n\n  // Remove all event listeners and clean up\n  destroy() {\n    this.emitter.destroy()\n\n    this.element.removeEventListener('wheel', this.onWheel, {\n      passive: false,\n    })\n    this.element.removeEventListener('touchstart', this.onTouchStart, {\n      passive: false,\n    })\n    this.element.removeEventListener('touchmove', this.onTouchMove, {\n      passive: false,\n    })\n    this.element.removeEventListener('touchend', this.onTouchEnd, {\n      passive: false,\n    })\n  }\n\n  // Event handler for 'touchstart' event\n  onTouchStart = (event) => {\n    const { clientX, clientY } = event.targetTouches\n      ? event.targetTouches[0]\n      : event\n\n    this.touchStart.x = clientX\n    this.touchStart.y = clientY\n\n    this.lastDelta = {\n      x: 0,\n      y: 0,\n    }\n\n    this.emitter.emit('scroll', {\n      deltaX: 0,\n      deltaY: 0,\n      event,\n    })\n  }\n\n  // Event handler for 'touchmove' event\n  onTouchMove = (event) => {\n    const { clientX, clientY } = event.targetTouches\n      ? event.targetTouches[0]\n      : event\n\n    const deltaX = -(clientX - this.touchStart.x) * this.touchMultiplier\n    const deltaY = -(clientY - this.touchStart.y) * this.touchMultiplier\n\n    this.touchStart.x = clientX\n    this.touchStart.y = clientY\n\n    this.lastDelta = {\n      x: deltaX,\n      y: deltaY,\n    }\n\n    this.emitter.emit('scroll', {\n      deltaX,\n      deltaY,\n      event,\n    })\n  }\n\n  onTouchEnd = (event) => {\n    this.emitter.emit('scroll', {\n      deltaX: this.lastDelta.x,\n      deltaY: this.lastDelta.y,\n      event,\n    })\n  }\n\n  // Event handler for 'wheel' event\n  onWheel = (event) => {\n    let { deltaX, deltaY } = event\n\n    if (this.normalizeWheel) {\n      deltaX = clamp(-100, deltaX, 100)\n      deltaY = clamp(-100, deltaY, 100)\n    }\n\n    deltaX *= this.wheelMultiplier\n    deltaY *= this.wheelMultiplier\n\n    this.emitter.emit('scroll', { deltaX, deltaY, event })\n  }\n}\n","import { version } from '../package.json'\nimport { Animate } from './animate'\nimport { Dimensions } from './dimensions'\nimport { Emitter } from './emitter'\nimport { clamp, modulo } from './maths'\nimport { VirtualScroll } from './virtual-scroll'\n\n// Technical explanation\n// - listen to 'wheel' events\n// - prevent 'wheel' event to prevent scroll\n// - normalize wheel delta\n// - add delta to targetScroll\n// - animate scroll to targetScroll (smooth context)\n// - if animation is not running, listen to 'scroll' events (native context)\n\nexport default class Lenis {\n  // isScrolling = true when scroll is animating\n  // isStopped = true if user should not be able to scroll - enable/disable programmatically\n  // isSmooth = true if scroll should be animated\n  // isLocked = same as isStopped but enabled/disabled when scroll reaches target\n\n  /**\n   * @typedef {(t: number) => number} EasingFunction\n   * @typedef {'vertical' | 'horizontal'} Orientation\n   * @typedef {'vertical' | 'horizontal' | 'both'} GestureOrientation\n   *\n   * @typedef LenisOptions\n   * @property {Window | HTMLElement} [wrapper]\n   * @property {HTMLElement} [content]\n   * @property {Window | HTMLElement} [wheelEventsTarget] // deprecated\n   * @property {Window | HTMLElement} [eventsTarget]\n   * @property {boolean} [smoothWheel]\n   * @property {boolean} [syncTouch]\n   * @property {number} [syncTouchLerp]\n  //  * @property {number} [__iosNoInertiaSyncTouchLerp]\n   * @property {number} [touchInertiaMultiplier]\n   * @property {number} [duration]\n   * @property {EasingFunction} [easing]\n   * @property {number} [lerp]\n   * @property {boolean} [infinite]\n   * @property {Orientation} [orientation]\n   * @property {GestureOrientation} [gestureOrientation]\n   * @property {number} [touchMultiplier]\n   * @property {number} [wheelMultiplier]\n   * @property {boolean} [normalizeWheel] \n   * @property {boolean} [autoResize]\n   *\n   * @param {LenisOptions}\n   */\n  constructor({\n    wrapper = window,\n    content = document.documentElement,\n    wheelEventsTarget = wrapper, // deprecated\n    eventsTarget = wheelEventsTarget,\n    smoothWheel = true,\n    syncTouch = false,\n    syncTouchLerp = 0.075,\n    // __iosNoInertiaSyncTouchLerp = 0.4, // should be 1 but had to leave 0.4 for iOS (testing purpose)\n    touchInertiaMultiplier = 35,\n    duration, // in seconds\n    easing = (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),\n    lerp = !duration && 0.1,\n    infinite = false,\n    orientation = 'vertical', // vertical, horizontal\n    gestureOrientation = 'vertical', // vertical, horizontal, both\n    touchMultiplier = 1,\n    wheelMultiplier = 1,\n    normalizeWheel = false, // deprecated\n    autoResize = true,\n  } = {}) {\n    window.lenisVersion = version\n\n    // if wrapper is html or body, fallback to window\n    if (wrapper === document.documentElement || wrapper === document.body) {\n      wrapper = window\n    }\n\n    this.options = {\n      wrapper,\n      content,\n      wheelEventsTarget,\n      eventsTarget,\n      smoothWheel,\n      syncTouch,\n      syncTouchLerp,\n      // __iosNoInertiaSyncTouchLerp,\n      touchInertiaMultiplier,\n      duration,\n      easing,\n      lerp,\n      infinite,\n      gestureOrientation,\n      orientation,\n      touchMultiplier,\n      wheelMultiplier,\n      normalizeWheel,\n      autoResize,\n    }\n\n    this.animate = new Animate()\n    this.emitter = new Emitter()\n    this.dimensions = new Dimensions({ wrapper, content, autoResize })\n    this.toggleClass('lenis', true)\n\n    this.velocity = 0\n    this.isLocked = false\n    this.isStopped = false\n    this.isSmooth = syncTouch || smoothWheel\n    this.isScrolling = false\n    this.targetScroll = this.animatedScroll = this.actualScroll\n\n    this.options.wrapper.addEventListener('scroll', this.onNativeScroll, {\n      passive: false,\n    })\n\n    this.virtualScroll = new VirtualScroll(eventsTarget, {\n      touchMultiplier,\n      wheelMultiplier,\n      normalizeWheel,\n    })\n    this.virtualScroll.on('scroll', this.onVirtualScroll)\n  }\n\n  destroy() {\n    this.emitter.destroy()\n\n    this.options.wrapper.removeEventListener('scroll', this.onNativeScroll, {\n      passive: false,\n    })\n\n    this.virtualScroll.destroy()\n    this.dimensions.destroy()\n\n    this.toggleClass('lenis', false)\n    this.toggleClass('lenis-smooth', false)\n    this.toggleClass('lenis-scrolling', false)\n    this.toggleClass('lenis-stopped', false)\n    this.toggleClass('lenis-locked', false)\n  }\n\n  on(event, callback) {\n    return this.emitter.on(event, callback)\n  }\n\n  off(event, callback) {\n    return this.emitter.off(event, callback)\n  }\n\n  setScroll(scroll) {\n    // apply scroll value immediately\n    if (this.isHorizontal) {\n      this.rootElement.scrollLeft = scroll\n    } else {\n      this.rootElement.scrollTop = scroll\n    }\n  }\n\n  onVirtualScroll = ({ deltaX, deltaY, event }) => {\n    // keep zoom feature\n    if (event.ctrlKey) return\n\n    const isTouch = event.type.includes('touch')\n    const isWheel = event.type.includes('wheel')\n\n    const isTapToStop =\n      this.options.syncTouch && isTouch && event.type === 'touchstart'\n\n    if (isTapToStop) {\n      this.reset()\n      return\n    }\n\n    const isClick = deltaX === 0 && deltaY === 0 // click event\n\n    // const isPullToRefresh =\n    //   this.options.gestureOrientation === 'vertical' &&\n    //   this.scroll === 0 &&\n    //   !this.options.infinite &&\n    //   deltaY <= 5 // touch pull to refresh, not reliable yet\n\n    const isUnknownGesture =\n      (this.options.gestureOrientation === 'vertical' && deltaY === 0) ||\n      (this.options.gestureOrientation === 'horizontal' && deltaX === 0)\n\n    if (isClick || isUnknownGesture) {\n      // console.log('prevent')\n      return\n    }\n\n    // catch if scrolling on nested scroll elements\n    let composedPath = event.composedPath()\n    composedPath = composedPath.slice(0, composedPath.indexOf(this.rootElement)) // remove parents elements\n\n    if (\n      !!composedPath.find(\n        (node) =>\n          node.hasAttribute?.('data-lenis-prevent') ||\n          (isTouch && node.hasAttribute?.('data-lenis-prevent-touch')) ||\n          (isWheel && node.hasAttribute?.('data-lenis-prevent-wheel')) ||\n          node.classList?.contains('lenis') // nested lenis instance\n      )\n    )\n      return\n\n    if (this.isStopped || this.isLocked) {\n      event.preventDefault()\n      return\n    }\n\n    this.isSmooth =\n      (this.options.syncTouch && isTouch) ||\n      (this.options.smoothWheel && isWheel)\n\n    if (!this.isSmooth) {\n      this.isScrolling = false\n      this.animate.stop()\n      return\n    }\n\n    event.preventDefault()\n\n    let delta = deltaY\n    if (this.options.gestureOrientation === 'both') {\n      delta = Math.abs(deltaY) > Math.abs(deltaX) ? deltaY : deltaX\n    } else if (this.options.gestureOrientation === 'horizontal') {\n      delta = deltaX\n    }\n\n    const syncTouch = isTouch && this.options.syncTouch\n    const isTouchEnd = isTouch && event.type === 'touchend'\n\n    const hasTouchInertia = isTouchEnd && Math.abs(delta) > 5\n\n    if (hasTouchInertia) {\n      delta = this.velocity * this.options.touchInertiaMultiplier\n    }\n\n    this.scrollTo(this.targetScroll + delta, {\n      programmatic: false,\n      ...(syncTouch\n        ? {\n            lerp: hasTouchInertia ? this.options.syncTouchLerp : 1,\n          }\n        : {\n            lerp: this.options.lerp,\n            duration: this.options.duration,\n            easing: this.options.easing,\n          }),\n    })\n  }\n\n  resize() {\n    this.dimensions.resize()\n  }\n\n  emit() {\n    this.emitter.emit('scroll', this)\n  }\n\n  onNativeScroll = () => {\n    if (this.__preventNextScrollEvent) return\n\n    if (!this.isScrolling) {\n      const lastScroll = this.animatedScroll\n      this.animatedScroll = this.targetScroll = this.actualScroll\n      this.velocity = 0\n      this.direction = Math.sign(this.animatedScroll - lastScroll)\n      this.emit()\n    }\n  }\n\n  reset() {\n    this.isLocked = false\n    this.isScrolling = false\n    this.animatedScroll = this.targetScroll = this.actualScroll\n    this.velocity = 0\n    this.animate.stop()\n  }\n\n  start() {\n    this.isStopped = false\n\n    this.reset()\n  }\n\n  stop() {\n    this.isStopped = true\n    this.animate.stop()\n\n    this.reset()\n  }\n\n  raf(time) {\n    const deltaTime = time - (this.time || time)\n    this.time = time\n\n    this.animate.advance(deltaTime * 0.001)\n  }\n\n  scrollTo(\n    target,\n    {\n      offset = 0,\n      immediate = false,\n      lock = false,\n      duration = this.options.duration,\n      easing = this.options.easing,\n      lerp = !duration && this.options.lerp,\n      onComplete = null,\n      force = false, // scroll even if stopped\n      programmatic = true, // called from outside of the class\n    } = {}\n  ) {\n    if ((this.isStopped || this.isLocked) && !force) return\n\n    // keywords\n    if (['top', 'left', 'start'].includes(target)) {\n      target = 0\n    } else if (['bottom', 'right', 'end'].includes(target)) {\n      target = this.limit\n    } else {\n      let node\n\n      if (typeof target === 'string') {\n        // CSS selector\n        node = document.querySelector(target)\n      } else if (target?.nodeType) {\n        // Node element\n        node = target\n      }\n\n      if (node) {\n        if (this.options.wrapper !== window) {\n          // nested scroll offset correction\n          const wrapperRect = this.options.wrapper.getBoundingClientRect()\n          offset -= this.isHorizontal ? wrapperRect.left : wrapperRect.top\n        }\n\n        const rect = node.getBoundingClientRect()\n\n        target =\n          (this.isHorizontal ? rect.left : rect.top) + this.animatedScroll\n      }\n    }\n\n    if (typeof target !== 'number') return\n\n    target += offset\n    target = Math.round(target)\n\n    if (this.options.infinite) {\n      if (programmatic) {\n        this.targetScroll = this.animatedScroll = this.scroll\n      }\n    } else {\n      target = clamp(0, target, this.limit)\n    }\n\n    if (immediate) {\n      this.animatedScroll = this.targetScroll = target\n      this.setScroll(this.scroll)\n      this.reset()\n      onComplete?.(this)\n      return\n    }\n\n    if (!programmatic) {\n      if (target === this.targetScroll) return\n\n      this.targetScroll = target\n    }\n\n    this.animate.fromTo(this.animatedScroll, target, {\n      duration,\n      easing,\n      lerp,\n      onStart: () => {\n        // started\n        if (lock) this.isLocked = true\n        this.isScrolling = true\n      },\n      onUpdate: (value, completed) => {\n        this.isScrolling = true\n\n        // updated\n        this.velocity = value - this.animatedScroll\n        this.direction = Math.sign(this.velocity)\n\n        this.animatedScroll = value\n        this.setScroll(this.scroll)\n\n        if (programmatic) {\n          // wheel during programmatic should stop it\n          this.targetScroll = value\n        }\n\n        if (!completed) this.emit()\n\n        if (completed) {\n          this.reset()\n          this.emit()\n          onComplete?.(this)\n\n          // avoid emitting event twice\n          this.__preventNextScrollEvent = true\n          requestAnimationFrame(() => {\n            delete this.__preventNextScrollEvent\n          })\n        }\n      },\n    })\n  }\n\n  get rootElement() {\n    return this.options.wrapper === window\n      ? document.documentElement\n      : this.options.wrapper\n  }\n\n  get limit() {\n    return this.dimensions.limit[this.isHorizontal ? 'x' : 'y']\n  }\n\n  get isHorizontal() {\n    return this.options.orientation === 'horizontal'\n  }\n\n  get actualScroll() {\n    // value browser takes into account\n    return this.isHorizontal\n      ? this.rootElement.scrollLeft\n      : this.rootElement.scrollTop\n  }\n\n  get scroll() {\n    return this.options.infinite\n      ? modulo(this.animatedScroll, this.limit)\n      : this.animatedScroll\n  }\n\n  get progress() {\n    // avoid progress to be NaN\n    return this.limit === 0 ? 1 : this.scroll / this.limit\n  }\n\n  get isSmooth() {\n    return this.__isSmooth\n  }\n\n  set isSmooth(value) {\n    if (this.__isSmooth !== value) {\n      this.__isSmooth = value\n      this.toggleClass('lenis-smooth', value)\n    }\n  }\n\n  get isScrolling() {\n    return this.__isScrolling\n  }\n\n  set isScrolling(value) {\n    if (this.__isScrolling !== value) {\n      this.__isScrolling = value\n      this.toggleClass('lenis-scrolling', value)\n    }\n  }\n\n  get isStopped() {\n    return this.__isStopped\n  }\n\n  set isStopped(value) {\n    if (this.__isStopped !== value) {\n      this.__isStopped = value\n      this.toggleClass('lenis-stopped', value)\n    }\n  }\n\n  get isLocked() {\n    return this.__isLocked\n  }\n\n  set isLocked(value) {\n    if (this.__isLocked !== value) {\n      this.__isLocked = value\n      this.toggleClass('lenis-locked', value)\n    }\n  }\n\n  get className() {\n    let className = 'lenis'\n    if (this.isStopped) className += ' lenis-stopped'\n    if (this.isLocked) className += ' lenis-locked'\n    if (this.isScrolling) className += ' lenis-scrolling'\n    if (this.isSmooth) className += ' lenis-smooth'\n    return className\n  }\n\n  toggleClass(name, value) {\n    this.rootElement.classList.toggle(name, value)\n    this.emitter.emit('className change', this)\n  }\n}\n"],"mappings":"AACO,SAASA,EAAMA,CAAA,EAAKC,CAAA,EAAOC,CAAA;EAChC,OAAOC,IAAA,CAAKC,GAAA,CAAIJ,CAAA,EAAKG,IAAA,CAAKE,GAAA,CAAIJ,CAAA,EAAOC,CAAA,EACvC;AAAA;ACAO,MAAMI,OAAA;EAEXC,QAAQN,CAAA;IACN,KAAK,KAAKO,SAAA,EAAW;IAErB,IAAIN,CAAA,IAAY;IAEhB,IAAI,KAAKO,IAAA,EACP,KAAKC,KAAA,IDKUC,CAAA,GCLG,KAAKD,KAAA,EDKLE,CAAA,GCLY,KAAKC,EAAA,EDKdC,CAAA,GCL8B,KAAZ,KAAKL,IAAA,EDKfM,CAAA,GCL0Bd,CAAA,EDAtD,UAAcD,CAAA,EAAGC,CAAA,EAAGC,CAAA;MACzB,QAAQ,IAAIA,CAAA,IAAKF,CAAA,GAAIE,CAAA,GAAID,CAC3B;IAAA,CAIS,CAAKU,CAAA,EAAGC,CAAA,EAAG,IAAIT,IAAA,CAAKa,GAAA,EAAKF,CAAA,GAASC,CAAA,KCLjCZ,IAAA,CAAKc,KAAA,CAAM,KAAKP,KAAA,MAAW,KAAKG,EAAA,KAClC,KAAKH,KAAA,GAAQ,KAAKG,EAAA,EAClBX,CAAA,IAAY,QAET;MACL,KAAKgB,WAAA,IAAejB,CAAA;MACpB,MAAMU,CAAA,GAAiBX,CAAA,CAAM,GAAG,KAAKkB,WAAA,GAAc,KAAKC,QAAA,EAAU;MAElEjB,CAAA,GAAYS,CAAA,IAAkB;MAC9B,MAAMC,CAAA,GAAgBV,CAAA,GAAY,IAAI,KAAKkB,MAAA,CAAOT,CAAA;MAClD,KAAKD,KAAA,GAAQ,KAAKW,IAAA,IAAQ,KAAKR,EAAA,GAAK,KAAKQ,IAAA,IAAQT,CAClD;IAAA;IDPE,IAAcD,CAAA,EAAGC,CAAA,EAAGE,CAAA,EAAQC,CAAA;ICU/B,KAAKO,QAAA,GAAW,KAAKZ,KAAA,EAAOR,CAAA,GAExBA,CAAA,IACF,KAAKqB,IAAA,EAER;EAAA;EAGDA,KAAA;IACE,KAAKf,SAAA,IAAY,CAClB;EAAA;EAIDgB,OACExB,CAAA,EACAC,CAAA;IACAQ,IAAA,EAAEP,CAAA,GAAO;IAAGiB,QAAA,EAAER,CAAA,GAAW;IAACS,MAAA,EAAER,CAAA,GAAUZ,CAAA,IAAMA,CAAA;IAACyB,OAAA,EAAEX,CAAA;IAAOQ,QAAA,EAAEP;EAAA;IAExD,KAAKM,IAAA,GAAO,KAAKX,KAAA,GAAQV,CAAA,EACzB,KAAKa,EAAA,GAAKZ,CAAA,EACV,KAAKQ,IAAA,GAAOP,CAAA,EACZ,KAAKiB,QAAA,GAAWR,CAAA,EAChB,KAAKS,MAAA,GAASR,CAAA,EACd,KAAKM,WAAA,GAAc,GACnB,KAAKV,SAAA,IAAY,GAEjBM,CAAA,MACA,KAAKQ,QAAA,GAAWP,CACjB;EAAA;AAAA;ACrDI,MAAMW,UAAA;EACXC,YAAA;IAAYC,OAAA,EAAE5B,CAAA;IAAO6B,OAAA,EAAE5B,CAAA;IAAO6B,UAAA,EAAE5B,CAAA,IAAa;EAAA,IAAS;IAIpD,IAHA,KAAK0B,OAAA,GAAU5B,CAAA,EACf,KAAK6B,OAAA,GAAU5B,CAAA,EAEXC,CAAA,EAAY;MACd,MAAMF,CAAA,GCRL,UAAkBA,CAAA,EAAUC,CAAA;QACjC,IAAIC,CAAA;QACJ,OAAO;UACL,IAAIS,CAAA,GAAOoB,SAAA;YACPnB,CAAA,GAAU;UACdoB,YAAA,CAAa9B,CAAA,GACbA,CAAA,GAAQ+B,UAAA,CAAW;YACjBjC,CAAA,CAASkC,KAAA,CAAMtB,CAAA,EAASD,CAAA,CACzB;UAAA,GAAEV,CAAA,CACJ;QAAA,CACH;MAAA,CDFqB,CAAS,KAAKkC,MAAA,EAAQ;MAEjC,KAAKP,OAAA,KAAYQ,MAAA,KACnB,KAAKC,qBAAA,GAAwB,IAAIC,cAAA,CAAetC,CAAA,GAChD,KAAKqC,qBAAA,CAAsBE,OAAA,CAAQ,KAAKX,OAAA,IAG1C,KAAKY,qBAAA,GAAwB,IAAIF,cAAA,CAAetC,CAAA,GAChD,KAAKwC,qBAAA,CAAsBD,OAAA,CAAQ,KAAKV,OAAA,CACzC;IAAA;IAED,KAAKM,MAAA,EACN;EAAA;EAEDM,QAAA;IACE,KAAKJ,qBAAA,EAAuBK,UAAA,IAC5B,KAAKF,qBAAA,EAAuBE,UAAA,EAC7B;EAAA;EAEDP,MAAA,GAASA,CAAA;IACP,KAAKQ,eAAA,IACL,KAAKC,eAAA,EAAiB;EAAA;EAGxBD,eAAA,GAAkBA,CAAA;IACZ,KAAKf,OAAA,KAAYQ,MAAA,IACnB,KAAKS,KAAA,GAAQT,MAAA,CAAOU,UAAA,EACpB,KAAKC,MAAA,GAASX,MAAA,CAAOY,WAAA,KAErB,KAAKH,KAAA,GAAQ,KAAKjB,OAAA,CAAQqB,WAAA,EAC1B,KAAKF,MAAA,GAAS,KAAKnB,OAAA,CAAQsB,YAAA,CAC5B;EAAA;EAGHN,eAAA,GAAkBA,CAAA;IAChB,KAAKO,YAAA,GAAe,KAAKtB,OAAA,CAAQsB,YAAA,EACjC,KAAKC,WAAA,GAAc,KAAKvB,OAAA,CAAQuB,WAAW;EAAA;EAG7C,IAAAC,KAAIA,CAAA;IACF,OAAO;MACLC,CAAA,EAAG,KAAKF,WAAA,GAAc,KAAKP,KAAA;MAC3BU,CAAA,EAAG,KAAKJ,YAAA,GAAe,KAAKJ;IAAA,CAE/B;EAAA;AAAA;AEpDI,MAAMS,OAAA;EACX7B,YAAA;IACE,KAAK8B,MAAA,GAAS,CAAE,CACjB;EAAA;EAEDC,KAAK1D,CAAA,KAAUC,CAAA;IACb,IAAIC,CAAA,GAAY,KAAKuD,MAAA,CAAOzD,CAAA,KAAU;IACtC,KAAK,IAAIA,CAAA,GAAI,GAAGW,CAAA,GAAST,CAAA,CAAUyD,MAAA,EAAQ3D,CAAA,GAAIW,CAAA,EAAQX,CAAA,IACrDE,CAAA,CAAUF,CAAA,KAAMC,CAAA,CAEnB;EAAA;EAED2D,GAAG5D,CAAA,EAAOC,CAAA;IAKR,OAHA,KAAKwD,MAAA,CAAOzD,CAAA,GAAQ6D,IAAA,CAAK5D,CAAA,MAAQ,KAAKwD,MAAA,CAAOzD,CAAA,IAAS,CAACC,CAAA,IAGhD;MACL,KAAKwD,MAAA,CAAOzD,CAAA,IAAS,KAAKyD,MAAA,CAAOzD,CAAA,GAAQ8D,MAAA,CAAQ9D,CAAA,IAAMC,CAAA,KAAOD,CAAA,CAAE;IAAA,CAEnE;EAAA;EAED+D,IAAI/D,CAAA,EAAOC,CAAA;IACT,KAAKwD,MAAA,CAAOzD,CAAA,IAAS,KAAKyD,MAAA,CAAOzD,CAAA,GAAQ8D,MAAA,CAAQ9D,CAAA,IAAMC,CAAA,KAAaD,CAAA,CACrE;EAAA;EAEDyC,QAAA;IACE,KAAKgB,MAAA,GAAS,CAAE,CACjB;EAAA;AAAA;ACzBI,MAAMO,aAAA;EACXrC,YACE3B,CAAA;IACAiE,eAAA,EAAEhE,CAAA,GAAkB;IAACiE,eAAA,EAAEhE,CAAA,GAAkB;IAACiE,cAAA,EAAExD,CAAA,IAAiB;EAAA;IAE7D,KAAKyD,OAAA,GAAUpE,CAAA,EACf,KAAKiE,eAAA,GAAkBhE,CAAA,EACvB,KAAKiE,eAAA,GAAkBhE,CAAA,EACvB,KAAKiE,cAAA,GAAiBxD,CAAA,EAEtB,KAAK0D,UAAA,GAAa;MAChBf,CAAA,EAAG;MACHC,CAAA,EAAG;IAAA,GAGL,KAAKe,OAAA,GAAU,IAAId,OAAA,IAEnB,KAAKY,OAAA,CAAQG,gBAAA,CAAiB,SAAS,KAAKC,OAAA,EAAS;MAAEC,OAAA,GAAS;IAAA,IAChE,KAAKL,OAAA,CAAQG,gBAAA,CAAiB,cAAc,KAAKG,YAAA,EAAc;MAC7DD,OAAA,GAAS;IAAA,IAEX,KAAKL,OAAA,CAAQG,gBAAA,CAAiB,aAAa,KAAKI,WAAA,EAAa;MAC3DF,OAAA,GAAS;IAAA,IAEX,KAAKL,OAAA,CAAQG,gBAAA,CAAiB,YAAY,KAAKK,UAAA,EAAY;MACzDH,OAAA,GAAS;IAAA,EAEZ;EAAA;EAGDb,GAAG5D,CAAA,EAAOC,CAAA;IACR,OAAO,KAAKqE,OAAA,CAAQV,EAAA,CAAG5D,CAAA,EAAOC,CAAA,CAC/B;EAAA;EAGDwC,QAAA;IACE,KAAK6B,OAAA,CAAQ7B,OAAA,IAEb,KAAK2B,OAAA,CAAQS,mBAAA,CAAoB,SAAS,KAAKL,OAAA,EAAS;MACtDC,OAAA,GAAS;IAAA,IAEX,KAAKL,OAAA,CAAQS,mBAAA,CAAoB,cAAc,KAAKH,YAAA,EAAc;MAChED,OAAA,GAAS;IAAA,IAEX,KAAKL,OAAA,CAAQS,mBAAA,CAAoB,aAAa,KAAKF,WAAA,EAAa;MAC9DF,OAAA,GAAS;IAAA,IAEX,KAAKL,OAAA,CAAQS,mBAAA,CAAoB,YAAY,KAAKD,UAAA,EAAY;MAC5DH,OAAA,GAAS;IAAA,EAEZ;EAAA;EAGDC,YAAA,GAAgB1E,CAAA;IACd;MAAM8E,OAAA,EAAE7E,CAAA;MAAO8E,OAAA,EAAE7E;IAAA,IAAYF,CAAA,CAAMgF,aAAA,GAC/BhF,CAAA,CAAMgF,aAAA,CAAc,KACpBhF,CAAA;IAEJ,KAAKqE,UAAA,CAAWf,CAAA,GAAIrD,CAAA,EACpB,KAAKoE,UAAA,CAAWd,CAAA,GAAIrD,CAAA,EAEpB,KAAK+E,SAAA,GAAY;MACf3B,CAAA,EAAG;MACHC,CAAA,EAAG;IAAA,GAGL,KAAKe,OAAA,CAAQZ,IAAA,CAAK,UAAU;MAC1BwB,MAAA,EAAQ;MACRC,MAAA,EAAQ;MACRC,KAAA,EAAApF;IAAA,EACA;EAAA;EAIJ2E,WAAA,GAAe3E,CAAA;IACb;QAAM8E,OAAA,EAAE7E,CAAA;QAAO8E,OAAA,EAAE7E;MAAA,IAAYF,CAAA,CAAMgF,aAAA,GAC/BhF,CAAA,CAAMgF,aAAA,CAAc,KACpBhF,CAAA;MAEEW,CAAA,KAAWV,CAAA,GAAU,KAAKoE,UAAA,CAAWf,CAAA,IAAK,KAAKY,eAAA;MAC/CtD,CAAA,KAAWV,CAAA,GAAU,KAAKmE,UAAA,CAAWd,CAAA,IAAK,KAAKW,eAAA;IAErD,KAAKG,UAAA,CAAWf,CAAA,GAAIrD,CAAA,EACpB,KAAKoE,UAAA,CAAWd,CAAA,GAAIrD,CAAA,EAEpB,KAAK+E,SAAA,GAAY;MACf3B,CAAA,EAAG3C,CAAA;MACH4C,CAAA,EAAG3C;IAAA,GAGL,KAAK0D,OAAA,CAAQZ,IAAA,CAAK,UAAU;MAC1BwB,MAAA,EAAAvE,CAAA;MACAwE,MAAA,EAAAvE,CAAA;MACAwE,KAAA,EAAApF;IAAA,EACA;EAAA;EAGJ4E,UAAA,GAAc5E,CAAA;IACZ,KAAKsE,OAAA,CAAQZ,IAAA,CAAK,UAAU;MAC1BwB,MAAA,EAAQ,KAAKD,SAAA,CAAU3B,CAAA;MACvB6B,MAAA,EAAQ,KAAKF,SAAA,CAAU1B,CAAA;MACvB6B,KAAA,EAAApF;IAAA,EACA;EAAA;EAIJwE,OAAA,GAAWvE,CAAA;IACT;MAAIiF,MAAA,EAAEhF,CAAA;MAAMiF,MAAA,EAAExE;IAAA,IAAWV,CAAA;IAErB,KAAKkE,cAAA,KACPjE,CAAA,GAASF,CAAA,EAAO,KAAKE,CAAA,EAAQ,MAC7BS,CAAA,GAASX,CAAA,EAAO,KAAKW,CAAA,EAAQ,OAG/BT,CAAA,IAAU,KAAK+D,eAAA,EACftD,CAAA,IAAU,KAAKsD,eAAA,EAEf,KAAKK,OAAA,CAAQZ,IAAA,CAAK,UAAU;MAAEwB,MAAA,EAAAhF,CAAA;MAAQiF,MAAA,EAAAxE,CAAA;MAAQyE,KAAA,EAAAnF;IAAA,EAAQ;EAAA;AAAA;ACzG3C,MAAMoF,KAAA;EAkCnB1D,YAAA;IAAYC,OAAA,EACV5B,CAAA,GAAUoC,MAAA;IAAMP,OAAA,EAChB5B,CAAA,GAAUqF,QAAA,CAASC,eAAA;IAAeC,iBAAA,EAClCtF,CAAA,GAAoBF,CAAA;IAAOyF,YAAA,EAC3B9E,CAAA,GAAeT,CAAA;IAAiBwF,WAAA,EAChC9E,CAAA,IAAc;IAAI+E,SAAA,EAClB7E,CAAA,IAAY;IAAK8E,aAAA,EACjB7E,CAAA,GAAgB;IAAK8E,sBAAA,EAErBC,CAAA,GAAyB;IAAE3E,QAAA,EAC3B4E,CAAA;IAAQ3E,MAAA,EACR4E,CAAA,GAAUhG,CAAA,IAAMG,IAAA,CAAKE,GAAA,CAAI,GAAG,QAAQF,IAAA,CAAK8F,GAAA,CAAI,IAAI,KAAKjG,CAAA;IAAGS,IAAA,EACzDyF,CAAA,IAAQH,CAAA,IAAY;IAAGI,QAAA,EACvBC,CAAA,IAAW;IAAKC,WAAA,EAChBC,CAAA,GAAc;IAAUC,kBAAA,EACxBC,CAAA,GAAqB;IAAUtC,eAAA,EAC/BuC,CAAA,GAAkB;IAACxC,eAAA,EACnByC,CAAA,GAAkB;IAACvC,cAAA,EACnBwC,CAAA,IAAiB;IAAK7E,UAAA,EACtB8E,CAAA,IAAa;EAAA,IACX;IACFxE,MAAA,CAAOyE,YAAA,aAGH7G,CAAA,KAAYsF,QAAA,CAASC,eAAA,IAAmBvF,CAAA,KAAYsF,QAAA,CAASwB,IAAA,KAC/D9G,CAAA,GAAUoC,MAAA,GAGZ,KAAK2E,OAAA,GAAU;MACbnF,OAAA,EAAA5B,CAAA;MACA6B,OAAA,EAAA5B,CAAA;MACAuF,iBAAA,EAAAtF,CAAA;MACAuF,YAAA,EAAA9E,CAAA;MACA+E,WAAA,EAAA9E,CAAA;MACA+E,SAAA,EAAA7E,CAAA;MACA8E,aAAA,EAAA7E,CAAA;MAEA8E,sBAAA,EAAAC,CAAA;MACA3E,QAAA,EAAA4E,CAAA;MACA3E,MAAA,EAAA4E,CAAA;MACAvF,IAAA,EAAAyF,CAAA;MACAC,QAAA,EAAAC,CAAA;MACAG,kBAAA,EAAAC,CAAA;MACAH,WAAA,EAAAC,CAAA;MACApC,eAAA,EAAAuC,CAAA;MACAxC,eAAA,EAAAyC,CAAA;MACAvC,cAAA,EAAAwC,CAAA;MACA7E,UAAA,EAAA8E;IAAA,GAGF,KAAKI,OAAA,GAAU,IAAI1G,OAAA,IACnB,KAAKgE,OAAA,GAAU,IAAId,OAAA,IACnB,KAAKyD,UAAA,GAAa,IAAIvF,UAAA,CAAW;MAAEE,OAAA,EAAA5B,CAAA;MAAS6B,OAAA,EAAA5B,CAAA;MAAS6B,UAAA,EAAA8E;IAAA,IACrD,KAAKM,WAAA,CAAY,UAAS,IAE1B,KAAKC,QAAA,GAAW,GAChB,KAAKC,QAAA,IAAW,GAChB,KAAKC,SAAA,IAAY,GACjB,KAAKC,QAAA,GAAWxG,CAAA,IAAaF,CAAA,EAC7B,KAAK2G,WAAA,IAAc,GACnB,KAAKC,YAAA,GAAe,KAAKC,cAAA,GAAiB,KAAKC,YAAA,EAE/C,KAAKX,OAAA,CAAQnF,OAAA,CAAQ2C,gBAAA,CAAiB,UAAU,KAAKoD,cAAA,EAAgB;MACnElD,OAAA,GAAS;IAAA,IAGX,KAAKmD,aAAA,GAAgB,IAAI5D,aAAA,CAAcrD,CAAA,EAAc;MACnDuD,eAAA,EAAAuC,CAAA;MACAxC,eAAA,EAAAyC,CAAA;MACAvC,cAAA,EAAAwC;IAAA,IAEF,KAAKiB,aAAA,CAAchE,EAAA,CAAG,UAAU,KAAKiE,eAAA,CACtC;EAAA;EAEDpF,QAAA;IACE,KAAK6B,OAAA,CAAQ7B,OAAA,IAEb,KAAKsE,OAAA,CAAQnF,OAAA,CAAQiD,mBAAA,CAAoB,UAAU,KAAK8C,cAAA,EAAgB;MACtElD,OAAA,GAAS;IAAA,IAGX,KAAKmD,aAAA,CAAcnF,OAAA,IACnB,KAAKwE,UAAA,CAAWxE,OAAA,IAEhB,KAAKyE,WAAA,CAAY,UAAS,IAC1B,KAAKA,WAAA,CAAY,iBAAgB,IACjC,KAAKA,WAAA,CAAY,oBAAmB,IACpC,KAAKA,WAAA,CAAY,kBAAiB,IAClC,KAAKA,WAAA,CAAY,iBAAgB,EAClC;EAAA;EAEDtD,GAAG5D,CAAA,EAAOC,CAAA;IACR,OAAO,KAAKqE,OAAA,CAAQV,EAAA,CAAG5D,CAAA,EAAOC,CAAA,CAC/B;EAAA;EAED8D,IAAI/D,CAAA,EAAOC,CAAA;IACT,OAAO,KAAKqE,OAAA,CAAQP,GAAA,CAAI/D,CAAA,EAAOC,CAAA,CAChC;EAAA;EAED6H,UAAU9H,CAAA;IAEJ,KAAK+H,YAAA,GACP,KAAKC,WAAA,CAAYC,UAAA,GAAajI,CAAA,GAE9B,KAAKgI,WAAA,CAAYE,SAAA,GAAYlI,CAEhC;EAAA;EAED6H,eAAA,GAAkBA,CAAA;IAAG3C,MAAA,EAAAlF,CAAA;IAAQmF,MAAA,EAAAlF,CAAA;IAAQmF,KAAA,EAAAlF;EAAA;IAEnC,IAAIA,CAAA,CAAMiI,OAAA,EAAS;IAEnB,MAAMxH,CAAA,GAAUT,CAAA,CAAMkI,IAAA,CAAKC,QAAA,CAAS;MAC9BzH,CAAA,GAAUV,CAAA,CAAMkI,IAAA,CAAKC,QAAA,CAAS;IAKpC,IAFE,KAAKtB,OAAA,CAAQpB,SAAA,IAAahF,CAAA,IAA0B,iBAAfT,CAAA,CAAMkI,IAAA,EAI3C,YADA,KAAKE,KAAA;IAIP,MAAMxH,CAAA,GAAqB,MAAXd,CAAA,IAA2B,MAAXC,CAAA;MAQ1Bc,CAAA,GACiC,eAApC,KAAKgG,OAAA,CAAQR,kBAAA,IAAgD,MAAXtG,CAAA,IACd,iBAApC,KAAK8G,OAAA,CAAQR,kBAAA,IAAkD,MAAXvG,CAAA;IAEvD,IAAIc,CAAA,IAAWC,CAAA,EAEb;IAIF,IAAI+E,CAAA,GAAe5F,CAAA,CAAMqI,YAAA;IAGzB,IAFAzC,CAAA,GAAeA,CAAA,CAAa0C,KAAA,CAAM,GAAG1C,CAAA,CAAa2C,OAAA,CAAQ,KAAKT,WAAA,IAG3DlC,CAAA,CAAa4C,IAAA,CACZ1I,CAAA,IACCA,CAAA,CAAK2I,YAAA,GAAe,yBACnBhI,CAAA,IAAWX,CAAA,CAAK2I,YAAA,GAAe,+BAC/B/H,CAAA,IAAWZ,CAAA,CAAK2I,YAAA,GAAe,+BAChC3I,CAAA,CAAK4I,SAAA,EAAWC,QAAA,CAAS,WAG7B;IAEF,IAAI,KAAKxB,SAAA,IAAa,KAAKD,QAAA,EAEzB,YADAlH,CAAA,CAAM4I,cAAA;IAQR,IAJA,KAAKxB,QAAA,GACF,KAAKP,OAAA,CAAQpB,SAAA,IAAahF,CAAA,IAC1B,KAAKoG,OAAA,CAAQrB,WAAA,IAAe9E,CAAA,GAE1B,KAAK0G,QAAA,EAGR,OAFA,KAAKC,WAAA,IAAc,QACnB,KAAKP,OAAA,CAAQzF,IAAA;IAIfrB,CAAA,CAAM4I,cAAA;IAEN,IAAI/C,CAAA,GAAQ9F,CAAA;IAC4B,WAApC,KAAK8G,OAAA,CAAQR,kBAAA,GACfR,CAAA,GAAQ5F,IAAA,CAAK4I,GAAA,CAAI9I,CAAA,IAAUE,IAAA,CAAK4I,GAAA,CAAI/I,CAAA,IAAUC,CAAA,GAASD,CAAA,GACV,iBAApC,KAAK+G,OAAA,CAAQR,kBAAA,KACtBR,CAAA,GAAQ/F,CAAA;IAGV,MAAMgG,CAAA,GAAYrF,CAAA,IAAW,KAAKoG,OAAA,CAAQpB,SAAA;MAGpCO,CAAA,GAFavF,CAAA,IAA0B,eAAfT,CAAA,CAAMkI,IAAA,IAEEjI,IAAA,CAAK4I,GAAA,CAAIhD,CAAA,IAAS;IAEpDG,CAAA,KACFH,CAAA,GAAQ,KAAKoB,QAAA,GAAW,KAAKJ,OAAA,CAAQlB,sBAAA,GAGvC,KAAKmD,QAAA,CAAS,KAAKxB,YAAA,GAAezB,CAAA,EAAO;MACvCkD,YAAA,GAAc;MAAA,IACVjD,CAAA,GACA;QACEvF,IAAA,EAAMyF,CAAA,GAAkB,KAAKa,OAAA,CAAQnB,aAAA,GAAgB;MAAA,IAEvD;QACEnF,IAAA,EAAM,KAAKsG,OAAA,CAAQtG,IAAA;QACnBU,QAAA,EAAU,KAAK4F,OAAA,CAAQ5F,QAAA;QACvBC,MAAA,EAAQ,KAAK2F,OAAA,CAAQ3F;MAAA;IAAA,EAE3B;EAAA;EAGJe,OAAA;IACE,KAAK8E,UAAA,CAAW9E,MAAA,EACjB;EAAA;EAEDuB,KAAA;IACE,KAAKY,OAAA,CAAQZ,IAAA,CAAK,UAAU,KAC7B;EAAA;EAEDiE,cAAA,GAAiBA,CAAA;IACf,KAAI,KAAKuB,wBAAA,KAEJ,KAAK3B,WAAA,EAAa;MACrB,MAAMvH,CAAA,GAAa,KAAKyH,cAAA;MACxB,KAAKA,cAAA,GAAiB,KAAKD,YAAA,GAAe,KAAKE,YAAA,EAC/C,KAAKP,QAAA,GAAW,GAChB,KAAKgC,SAAA,GAAYhJ,IAAA,CAAKiJ,IAAA,CAAK,KAAK3B,cAAA,GAAiBzH,CAAA,GACjD,KAAK0D,IAAA,EACN;IAAA;EAAA;EAGH4E,MAAA;IACE,KAAKlB,QAAA,IAAW,GAChB,KAAKG,WAAA,IAAc,GACnB,KAAKE,cAAA,GAAiB,KAAKD,YAAA,GAAe,KAAKE,YAAA,EAC/C,KAAKP,QAAA,GAAW,GAChB,KAAKH,OAAA,CAAQzF,IAAA,EACd;EAAA;EAED8H,MAAA;IACE,KAAKhC,SAAA,IAAY,GAEjB,KAAKiB,KAAA,EACN;EAAA;EAED/G,KAAA;IACE,KAAK8F,SAAA,IAAY,GACjB,KAAKL,OAAA,CAAQzF,IAAA,IAEb,KAAK+G,KAAA,EACN;EAAA;EAEDgB,IAAItJ,CAAA;IACF,MAAMC,CAAA,GAAYD,CAAA,IAAQ,KAAKuJ,IAAA,IAAQvJ,CAAA;IACvC,KAAKuJ,IAAA,GAAOvJ,CAAA,EAEZ,KAAKgH,OAAA,CAAQzG,OAAA,CAAoB,OAAZN,CAAA,CACtB;EAAA;EAED+I,SACE/I,CAAA;IACAuJ,MAAA,EACEtJ,CAAA,GAAS;IAACuJ,SAAA,EACV9I,CAAA,IAAY;IAAK+I,IAAA,EACjB9I,CAAA,IAAO;IAAKO,QAAA,EACZL,CAAA,GAAW,KAAKiG,OAAA,CAAQ5F,QAAA;IAAQC,MAAA,EAChCL,CAAA,GAAS,KAAKgG,OAAA,CAAQ3F,MAAA;IAAMX,IAAA,EAC5BqF,CAAA,IAAQhF,CAAA,IAAY,KAAKiG,OAAA,CAAQtG,IAAA;IAAIkJ,UAAA,EACrC5D,CAAA,GAAa;IAAI6D,KAAA,EACjB5D,CAAA,IAAQ;IAAKiD,YAAA,EACb/C,CAAA,IAAe;EAAA,IACb,CAAE;IAEN,KAAK,KAAKmB,SAAA,KAAa,KAAKD,QAAA,IAAcpB,CAAA,EAA1C;MAGA,IAAI,CAAC,OAAO,QAAQ,SAASqC,QAAA,CAASpI,CAAA,GACpCA,CAAA,GAAS,OACJ,IAAI,CAAC,UAAU,SAAS,OAAOoI,QAAA,CAASpI,CAAA,GAC7CA,CAAA,GAAS,KAAKoD,KAAA,MACT;QACL,IAAIrD,CAAA;QAUJ,IARsB,mBAAXC,CAAA,GAETD,CAAA,GAAOsF,QAAA,CAASuE,aAAA,CAAc5J,CAAA,IACrBA,CAAA,EAAQ6J,QAAA,KAEjB9J,CAAA,GAAOC,CAAA,GAGLD,CAAA,EAAM;UACR,IAAI,KAAK+G,OAAA,CAAQnF,OAAA,KAAYQ,MAAA,EAAQ;YAEnC,MAAMpC,CAAA,GAAc,KAAK+G,OAAA,CAAQnF,OAAA,CAAQmI,qBAAA;YACzC7J,CAAA,IAAU,KAAK6H,YAAA,GAAe/H,CAAA,CAAYgK,IAAA,GAAOhK,CAAA,CAAYiK,GAC9D;UAAA;UAED,MAAMtJ,CAAA,GAAOX,CAAA,CAAK+J,qBAAA;UAElB9J,CAAA,IACG,KAAK8H,YAAA,GAAepH,CAAA,CAAKqJ,IAAA,GAAOrJ,CAAA,CAAKsJ,GAAA,IAAO,KAAKxC,cACrD;QAAA;MACF;MAED,IAAsB,mBAAXxH,CAAA,EAAX;QAaA,IAXAA,CAAA,IAAUC,CAAA,EACVD,CAAA,GAASE,IAAA,CAAKc,KAAA,CAAMhB,CAAA,GAEhB,KAAK8G,OAAA,CAAQZ,QAAA,GACXD,CAAA,KACF,KAAKsB,YAAA,GAAe,KAAKC,cAAA,GAAiB,KAAKyC,MAAA,IAGjDjK,CAAA,GAASD,CAAA,CAAM,GAAGC,CAAA,EAAQ,KAAKoD,KAAA,GAG7B1C,CAAA,EAKF,OAJA,KAAK8G,cAAA,GAAiB,KAAKD,YAAA,GAAevH,CAAA,EAC1C,KAAK6H,SAAA,CAAU,KAAKoC,MAAA,GACpB,KAAK5B,KAAA,SACLvC,CAAA,GAAa;QAIf,KAAKG,CAAA,EAAc;UACjB,IAAIjG,CAAA,KAAW,KAAKuH,YAAA,EAAc;UAElC,KAAKA,YAAA,GAAevH,CACrB;QAAA;QAED,KAAK+G,OAAA,CAAQxF,MAAA,CAAO,KAAKiG,cAAA,EAAgBxH,CAAA,EAAQ;UAC/CkB,QAAA,EAAAL,CAAA;UACAM,MAAA,EAAAL,CAAA;UACAN,IAAA,EAAAqF,CAAA;UACArE,OAAA,EAASA,CAAA;YAEHb,CAAA,KAAM,KAAKwG,QAAA,IAAW,IAC1B,KAAKG,WAAA,IAAc,CAAI;UAAA;UAEzBjG,QAAA,EAAUA,CAACtB,CAAA,EAAOC,CAAA;YAChB,KAAKsH,WAAA,IAAc,GAGnB,KAAKJ,QAAA,GAAWnH,CAAA,GAAQ,KAAKyH,cAAA,EAC7B,KAAK0B,SAAA,GAAYhJ,IAAA,CAAKiJ,IAAA,CAAK,KAAKjC,QAAA,GAEhC,KAAKM,cAAA,GAAiBzH,CAAA,EACtB,KAAK8H,SAAA,CAAU,KAAKoC,MAAA,GAEhBhE,CAAA,KAEF,KAAKsB,YAAA,GAAexH,CAAA,GAGjBC,CAAA,IAAW,KAAKyD,IAAA,IAEjBzD,CAAA,KACF,KAAKqI,KAAA,IACL,KAAK5E,IAAA,IACLqC,CAAA,GAAa,OAGb,KAAKmD,wBAAA,IAA2B,GAChCiB,qBAAA,CAAsB;cAAA,OACb,KAAKjB,wBAAwB;YAAA,GAEvC;UAAA;QAAA,EA/D2B;MAAA;IAhCiB;EAkGlD;EAED,IAAAlB,WAAIA,CAAA;IACF,OAAO,KAAKjB,OAAA,CAAQnF,OAAA,KAAYQ,MAAA,GAC5BkD,QAAA,CAASC,eAAA,GACT,KAAKwB,OAAA,CAAQnF,OAClB;EAAA;EAED,IAAAyB,KAAIA,CAAA;IACF,OAAO,KAAK4D,UAAA,CAAW5D,KAAA,CAAM,KAAK0E,YAAA,GAAe,MAAM,IACxD;EAAA;EAED,IAAAA,YAAIA,CAAA;IACF,OAAoC,iBAA7B,KAAKhB,OAAA,CAAQV,WACrB;EAAA;EAED,IAAAqB,YAAIA,CAAA;IAEF,OAAO,KAAKK,YAAA,GACR,KAAKC,WAAA,CAAYC,UAAA,GACjB,KAAKD,WAAA,CAAYE,SACtB;EAAA;EAED,IAAAgC,MAAIA,CAAA;IACF,OAAO,KAAKnD,OAAA,CAAQZ,QAAA,IN7ZDnG,CAAA,GM8ZR,KAAKyH,cAAA,EN9ZMxH,CAAA,GM8ZU,KAAKoD,KAAA,GN7Z9BrD,CAAA,GAAIC,CAAA,GAAKA,CAAA,IAAKA,CAAA,IM8ZjB,KAAKwH,cAAA;IN/ZN,IAAgBzH,CAAA,EAAGC,CMgavB;EAAA;EAED,IAAAmK,QAAIA,CAAA;IAEF,OAAsB,MAAf,KAAK/G,KAAA,GAAc,IAAI,KAAK6G,MAAA,GAAS,KAAK7G,KAClD;EAAA;EAED,IAAAiE,QAAIA,CAAA;IACF,OAAO,KAAK+C,UACb;EAAA;EAED,IAAA/C,QAAIA,CAAStH,CAAA;IACP,KAAKqK,UAAA,KAAerK,CAAA,KACtB,KAAKqK,UAAA,GAAarK,CAAA,EAClB,KAAKkH,WAAA,CAAY,gBAAgBlH,CAAA,EAEpC;EAAA;EAED,IAAAuH,WAAIA,CAAA;IACF,OAAO,KAAK+C,aACb;EAAA;EAED,IAAA/C,WAAIA,CAAYvH,CAAA;IACV,KAAKsK,aAAA,KAAkBtK,CAAA,KACzB,KAAKsK,aAAA,GAAgBtK,CAAA,EACrB,KAAKkH,WAAA,CAAY,mBAAmBlH,CAAA,EAEvC;EAAA;EAED,IAAAqH,SAAIA,CAAA;IACF,OAAO,KAAKkD,WACb;EAAA;EAED,IAAAlD,SAAIA,CAAUrH,CAAA;IACR,KAAKuK,WAAA,KAAgBvK,CAAA,KACvB,KAAKuK,WAAA,GAAcvK,CAAA,EACnB,KAAKkH,WAAA,CAAY,iBAAiBlH,CAAA,EAErC;EAAA;EAED,IAAAoH,QAAIA,CAAA;IACF,OAAO,KAAKoD,UACb;EAAA;EAED,IAAApD,QAAIA,CAASpH,CAAA;IACP,KAAKwK,UAAA,KAAexK,CAAA,KACtB,KAAKwK,UAAA,GAAaxK,CAAA,EAClB,KAAKkH,WAAA,CAAY,gBAAgBlH,CAAA,EAEpC;EAAA;EAED,IAAAyK,SAAIA,CAAA;IACF,IAAIzK,CAAA,GAAY;IAKhB,OAJI,KAAKqH,SAAA,KAAWrH,CAAA,IAAa,mBAC7B,KAAKoH,QAAA,KAAUpH,CAAA,IAAa,kBAC5B,KAAKuH,WAAA,KAAavH,CAAA,IAAa,qBAC/B,KAAKsH,QAAA,KAAUtH,CAAA,IAAa,kBACzBA,CACR;EAAA;EAEDkH,YAAYlH,CAAA,EAAMC,CAAA;IAChB,KAAK+H,WAAA,CAAYY,SAAA,CAAU8B,MAAA,CAAO1K,CAAA,EAAMC,CAAA,GACxC,KAAKqE,OAAA,CAAQZ,IAAA,CAAK,oBAAoB,KACvC;EAAA;AAAA;AAAA,SAAA2B,KAAA,IAAAsF,OAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}