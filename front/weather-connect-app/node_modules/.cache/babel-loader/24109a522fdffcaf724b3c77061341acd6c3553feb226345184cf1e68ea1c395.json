{"ast":null,"code":"import { useFrame as r } from \"@studio-freight/hamo\";\nimport e from \"@studio-freight/lenis\";\nimport t from \"clsx\";\nimport o from \"prop-types\";\nimport a, { createContext as n, useEffect as c, forwardRef as s, useRef as l, useState as i, useCallback as u, useImperativeHandle as f, useContext as m } from \"react\";\nimport { create as p } from \"zustand\";\nfunction d() {\n  return d = Object.assign ? Object.assign.bind() : function (r) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (r[o] = t[o]);\n    }\n    return r;\n  }, d.apply(this, arguments);\n}\nconst b = n(),\n  y = p(() => ({}));\nfunction h(r, e = [], t = 0) {\n  const {\n    lenis: o,\n    addCallback: a,\n    removeCallback: n\n  } = function () {\n    const r = m(b),\n      e = y();\n    return r ?? e;\n  }();\n  return c(() => {\n    if (r && a && n && o) return a(r, t), r(o), () => {\n      n(r);\n    };\n  }, [o, a, n, t, ...e]), o;\n}\nconst v = s(({\n  children: o,\n  root: n = !1,\n  options: s = {},\n  autoRaf: m = !0,\n  rafPriority: p = 0,\n  className: h,\n  ...v\n}, g) => {\n  const N = l(),\n    k = l(),\n    [C, O] = i(),\n    j = l([]),\n    w = u((r, e) => {\n      j.current.push({\n        callback: r,\n        priority: e\n      }), j.current.sort((r, e) => r.priority - e.priority);\n    }, []),\n    P = u(r => {\n      j.current = j.current.filter(e => e.callback !== r);\n    }, []);\n  f(g, () => ({\n    wrapper: N.current,\n    content: k.current,\n    lenis: C\n  }), [C]), c(() => {\n    const r = new e({\n      ...s,\n      ...(!n && {\n        wrapper: N.current,\n        content: k.current\n      })\n    });\n    return O(r), () => {\n      r.destroy(), O(void 0);\n    };\n  }, [n, JSON.stringify(s)]), r(r => {\n    m && C?.raf(r);\n  }, p), c(() => {\n    n && C && y.setState({\n      lenis: C,\n      addCallback: w,\n      removeCallback: P\n    });\n  }, [n, C, w, P]);\n  const E = u(r => {\n    for (let e = 0; e < j.current.length; e++) j.current[e].callback(r);\n  }, []);\n  c(() => (C?.on(\"scroll\", E), () => {\n    C?.off(\"scroll\", E);\n  }), [C, E]);\n  const R = u(() => {\n    N.current && (N.current.className = t(C?.className, h));\n  }, [C, h]);\n  return c(() => (R(), C?.on(\"className change\", R), () => {\n    C?.off(\"className change\", R);\n  }), [C, R]), a.createElement(b.Provider, {\n    value: {\n      lenis: C,\n      addCallback: w,\n      removeCallback: P\n    }\n  }, n ? o : a.createElement(\"div\", d({\n    ref: N,\n    className: t(C?.className, h)\n  }, v), a.createElement(\"div\", {\n    ref: k\n  }, o)));\n});\nv.displayName = \"ReactLenis\", v.propTypes = {\n  children: o.node,\n  root: o.bool,\n  options: o.object,\n  autoRaf: o.bool,\n  rafPriority: o.number,\n  className: o.string\n};\nexport { v as Lenis, b as LenisContext, v as ReactLenis, v as default, h as useLenis };","map":{"version":3,"names":["b","n","y","p","h","r","e","t","lenis","o","addCallback","a","removeCallback","m","c","v","s","children","root","options","autoRaf","rafPriority","className","g","N","l","k","C","O","i","j","w","u","current","push","callback","priority","sort","P","filter","f","wrapper","content","destroy","JSON","stringify","raf","setState","E","length","on","off","R","createElement","Provider","value","d","ref","displayName","propTypes","node","bool","object","number","string","Lenis","LenisContext","ReactLenis","default","useLenis"],"sources":["C:\\Users\\gabriel.custodio\\Documents\\GitHub\\WeatherConnect\\front\\weather-connect-app\\node_modules\\@studio-freight\\react-lenis\\src\\index.jsx"],"sourcesContent":["'use client'\r\n\r\nimport { useFrame } from '@studio-freight/hamo'\r\nimport Lenis from '@studio-freight/lenis'\r\nimport cn from 'clsx'\r\nimport PropTypes from 'prop-types' // ES6\r\nimport React, {\r\n  createContext,\r\n  forwardRef,\r\n  useCallback,\r\n  useContext,\r\n  useEffect,\r\n  useImperativeHandle,\r\n  useRef,\r\n  useState,\r\n} from 'react'\r\nimport { create } from 'zustand'\r\n\r\nexport const LenisContext = createContext()\r\n\r\nconst useRoot = create(() => ({}))\r\n\r\nfunction useCurrentLenis() {\r\n  const local = useContext(LenisContext)\r\n  const root = useRoot()\r\n\r\n  return local ?? root\r\n}\r\n\r\n/**\r\n * @param {CallbackFunction} [callback] Callback to be called on scroll\r\n * @param {Array=} [deps=[]] Dependencies for callback\r\n * @param {number=} [priority=0] Priority of callback (lower priority callbacks are called first)\r\n *\r\n * @returns {LenisInstance} Lenis instance\r\n */\r\nexport function useLenis(callback, deps = [], priority = 0) {\r\n  const { lenis, addCallback, removeCallback } = useCurrentLenis()\r\n\r\n  useEffect(() => {\r\n    if (!callback || !addCallback || !removeCallback || !lenis) return\r\n\r\n    addCallback(callback, priority)\r\n    callback(lenis)\r\n\r\n    return () => {\r\n      removeCallback(callback)\r\n    }\r\n  }, [lenis, addCallback, removeCallback, priority, ...deps])\r\n\r\n  return lenis\r\n}\r\n\r\n/**\r\n * @param {boolean=} [root] Whether Lenis will be initialized on document.documentElement\r\n * @param {ReactLenisOptions} [options={}] Lenis options {@link ReactLenisOptions}\r\n * @param {boolean=} [autoRaf=true] Whether to call Lenis.raf automatically on every frame\r\n * @param {number=} [rafPriority=0] Priority of Lenis.raf call (lower priority callbacks are called first)\r\n * @param {string=} [className] Class name to be applied to the wrapper\r\n */\r\nconst ReactLenis = forwardRef(\r\n  (\r\n    {\r\n      children,\r\n      root = false,\r\n      options = {},\r\n      autoRaf = true,\r\n      rafPriority = 0,\r\n      className,\r\n      ...props\r\n    },\r\n    ref\r\n  ) => {\r\n    const wrapperRef = useRef()\r\n    const contentRef = useRef()\r\n\r\n    const [lenis, setLenis] = useState()\r\n\r\n    const callbacksRefs = useRef([])\r\n\r\n    const addCallback = useCallback((callback, priority) => {\r\n      callbacksRefs.current.push({ callback, priority })\r\n      callbacksRefs.current.sort((a, b) => a.priority - b.priority)\r\n    }, [])\r\n\r\n    const removeCallback = useCallback((callback) => {\r\n      callbacksRefs.current = callbacksRefs.current.filter(\r\n        (cb) => cb.callback !== callback\r\n      )\r\n    }, [])\r\n\r\n    useImperativeHandle(\r\n      ref,\r\n      () => ({\r\n        wrapper: wrapperRef.current,\r\n        content: contentRef.current,\r\n        lenis,\r\n      }),\r\n      [lenis]\r\n    )\r\n\r\n    useEffect(() => {\r\n      const lenis = new Lenis({\r\n        ...options,\r\n        ...(!root && {\r\n          wrapper: wrapperRef.current,\r\n          content: contentRef.current,\r\n        }),\r\n      })\r\n\r\n      setLenis(lenis)\r\n\r\n      return () => {\r\n        lenis.destroy()\r\n        setLenis(undefined)\r\n      }\r\n    }, [root, JSON.stringify(options)])\r\n\r\n    useFrame((time) => {\r\n      if (autoRaf) {\r\n        lenis?.raf(time)\r\n      }\r\n    }, rafPriority)\r\n\r\n    useEffect(() => {\r\n      if (root && lenis) {\r\n        useRoot.setState({ lenis, addCallback, removeCallback })\r\n      }\r\n    }, [root, lenis, addCallback, removeCallback])\r\n\r\n    const onScroll = useCallback((e) => {\r\n      for (let i = 0; i < callbacksRefs.current.length; i++) {\r\n        callbacksRefs.current[i].callback(e)\r\n      }\r\n    }, [])\r\n\r\n    useEffect(() => {\r\n      lenis?.on('scroll', onScroll)\r\n\r\n      return () => {\r\n        lenis?.off('scroll', onScroll)\r\n      }\r\n    }, [lenis, onScroll])\r\n\r\n    const onClassNameChange = useCallback(() => {\r\n      if (wrapperRef.current)\r\n        wrapperRef.current.className = cn(lenis?.className, className)\r\n    }, [lenis, className])\r\n\r\n    useEffect(() => {\r\n      onClassNameChange()\r\n\r\n      lenis?.on('className change', onClassNameChange)\r\n\r\n      return () => {\r\n        lenis?.off('className change', onClassNameChange)\r\n      }\r\n    }, [lenis, onClassNameChange])\r\n\r\n    return (\r\n      <LenisContext.Provider value={{ lenis, addCallback, removeCallback }}>\r\n        {root ? (\r\n          children\r\n        ) : (\r\n          <div\r\n            ref={wrapperRef}\r\n            className={cn(lenis?.className, className)}\r\n            {...props}\r\n          >\r\n            <div ref={contentRef}>{children}</div>\r\n          </div>\r\n        )}\r\n      </LenisContext.Provider>\r\n    )\r\n  }\r\n)\r\nReactLenis.displayName = 'ReactLenis'\r\n\r\nReactLenis.propTypes = {\r\n  children: PropTypes.node,\r\n  root: PropTypes.bool,\r\n  options: PropTypes.object,\r\n  autoRaf: PropTypes.bool,\r\n  rafPriority: PropTypes.number,\r\n  className: PropTypes.string,\r\n}\r\n\r\nexport { ReactLenis as Lenis, ReactLenis }\r\nexport default ReactLenis\r\n\r\n/**\r\n * @callback EasingFunction\r\n * @param {number} rawValue\r\n * @returns {number} eased output value\r\n */\r\n\r\n/**\r\n * @callback CallbackFunction\r\n * @param {LenisInstance} instance\r\n */\r\n\r\n/**\r\n * @typedef {Object} CallbackEvents\r\n * @property {CallbackFunction[]} scroll scroll events\r\n */\r\n\r\n/**\r\n * @callback RAF\r\n * @param {number} time\r\n */\r\n\r\n/**\r\n * @typedef {Object} ScrollToParams\r\n * @property {number} [offset] equivalent to scroll-padding-top\r\n * @property {number} [lerp] animation interpolation rate\r\n * @property {number} [duration] animation duration (in seconds)\r\n * @property {EasingFunction} [easing] animation easing\r\n * @property {boolean} [immediate] ignore duration, easing and lerp\r\n * @property {boolean} [lock] whether or not to prevent the user from scrolling until the target is reached\r\n * @property {boolean} [force] reach target even if instance is stopped\r\n * @property {CallbackFunction} [onComplete] called when the target is reached\r\n */\r\n\r\n/**\r\n * @callback ScrollTo\r\n * @param {number|string|HTMLElement} target\r\n * @param {ScrollToParams} [options]\r\n */\r\n\r\n/**\r\n * @typedef {Object} ReactLenisOptions\r\n * @property {(HTMLElement|Window)} [wrapper=window] interpolation rate\r\n * @property {HTMLElement=} [content=document.documentElement]\r\n * @property {(HTMLElement|Window)} [wheelEventsTarget=wrapper]\r\n * @property {number=} [lerp=0.1] interpolation rate\r\n * @property {number=} [duration=1.2] scroll duration\r\n * @property {EasingFunction=} [easing=(t) => Math.min(1, 1.001 - Math.pow(2, -10 * t))] // easing function to apply to scroll values\r\n * @property {string=} [orientation='vertical'] scroll orientation\r\n * @property {string=} [gestureOrientation='vertical']\r\n * @property {boolean=} [smoothWheel=true]\r\n * @property {boolean=} [smoothTouch=false]\r\n * @property {boolean=} [syncTouch=false]\r\n * @property {number=} [syncTouchLerp=0.1]\r\n * @property {number=} [touchInertiaMultiplier=1]\r\n * @property {boolean=} [normalizeWheel=false]\r\n * @property {boolean=} [infinite=false] enable infinite scroll\r\n * @property {boolean=} [autoResize=true]\r\n */\r\n\r\n/**\r\n * @typedef {Object} Dimensions\r\n * @property {(HTMLElement|Window)} wrapper Wrapper lenis is applied to\r\n * @property {HTMLElement} content\r\n * @property {ResizeObserver} contentResizeObserver\r\n * @property {function():void} resize\r\n * @property {function():void} onContentResize\r\n * @property {function():void} onWrapperResize\r\n * @property {number} width viewport width\r\n * @property {number} height viewport height\r\n * @property {number} scrollWidth\r\n * @property {number} scrollHeight\r\n */\r\n\r\n/**\r\n * @typedef {Object} Emitter\r\n * @property {CallbackEvents} events\r\n */\r\n\r\n/**\r\n * @callback EventHandler\r\n * @param {string} id lenis instance event\r\n * @param {CallbackFunction} fn callback\r\n */\r\n\r\n/**\r\n * @typedef {Object} LenisInstance\r\n * @property {number} animatedScroll Current scroll value\r\n * @property {Dimensions} dimensions Dimensions instance\r\n * @property {number} direction scroll direction; 0: stopped, 1: scrolling up, -1: scrolling down\r\n * @property {Emitter} emitter Emitter instance\r\n * @property {ReactLenisOptions} options Instance options {@link ReactLenisOptions}\r\n * @property {number} targetScroll Target scroll value\r\n * @property {number} time Time elapsed since instance creation\r\n * @property {number} actualScroll Current scroll value registered by the browser\r\n * @property {number} velocity Current scroll velocity\r\n * @property {boolean} isHorizontal Whether or not the instance is horizontal\r\n * @property {boolean} isScrolling Whether or not the instance is being animated\r\n * @property {boolean} isSmooth Whether or not the instance is animated\r\n * @property {boolean} isStopped Whether or not the user should be able to scroll\r\n * @property {number} limit Maximum scroll value\r\n * @property {number} progress Scroll progress from 0 to 1\r\n * @property {HTMLElement} rootElement Element on which Lenis is instanced\r\n * @property {number} scroll Current scroll value (handles infinite scroll if activated)\r\n * @property {function():void} stop Pauses the scroll\r\n * @property {function():void} start Resumes the scroll\r\n * @property {function():void} resize Compute internal sizes, has to be used if autoResize option is false\r\n * @property {function():void} destroy Destroys the instance and removes all events\r\n * @property {EventHandler} on Lenis event listener\r\n * @property {ScrollTo} scrollTo Scroll to target\r\n * @property {RAF} raf Must be called every frame for internal usage\r\n */\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}